function [stimuli,n,T] = blockgen_stim(n,T,param1_min,param1_max,param2_min,param2_max,condition,saving)

% BLOCKGEN_STIM Generate the polar coordinates for T random circular numerosity
% stimuli given the variable constraints of the block. load the .mat file generated by 
% intensive_radii_relation.m before running this function
%
% [stimuli,n,T] = blockgen_stim(n,T,param1_min,param1_max,param2_min,param2_max,condition)
% will return a struct 'stimuli' with the polar coordinates of the corresponding T stimuli.
%
% n is the number of items to be displayed in the stimulus
% T is the number of stimuli in the block
% param1 can either be Item Surface Area (Intensive) or Total Surface Area (Extensive)
% param2 can either be Spacing (Intensive) or Total Spacing (Extensive)
% condition determines the selection of Intensive (=0) or Extensive (=1) parameters as param1 and param2
% saving determines if the struct 'stimuli' is to be saved (=1) or not (=0)

if condition == 1 % Assignment of parameters
    isa_max = param1_max/n;
    isa_min = param1_min/n;
    spacing_min = param2_min/n;
    spacing_max = param2_max/n;
else
    isa_max = param1_max;
    isa_min = param1_min;
    spacing_min = param2_min;
    spacing_max = param2_max;
end

stim_isurf = isa_min + (isa_max-isa_min)*rand(T,1); % Generate the uniformly random ISA and Spacing data-points
stim_isurf = stim_isurf - mean(stim_isurf);
stim_isurf = stim_isurf + (isa_min+isa_max)/(2);
stim_isurf_mino = mean(stim_isurf) - min(stim_isurf);
stim_isurf_mine = mean(stim_isurf) - isa_min;
if stim_isurf_mine - stim_isurf_mino < 0
    stim_isurf = (stim_isurf - mean(stim_isurf))/stim_isurf_mino*stim_isurf_mine + mean(stim_isurf);
end
stim_isurf_maxo = max(stim_isurf) - mean(stim_isurf);
stim_isurf_maxe = isa_max - mean(stim_isurf);
if stim_isurf_maxe - stim_isurf_maxo < 0
    stim_isurf = (stim_isurf - mean(stim_isurf))/stim_isurf_maxo*stim_isurf_maxe + mean(stim_isurf);
end
    
stim_spacing = spacing_min + (spacing_max-spacing_min)*rand(T,1);
stim_spacing = stim_spacing - mean(stim_spacing);
stim_spacing = stim_spacing + (spacing_min+spacing_max)/(2);
stim_spacing_mino = mean(stim_spacing) - min(stim_spacing);
stim_spacing_mine = mean(stim_spacing) - spacing_min;
if stim_spacing_mine - stim_spacing_mino < 0
    stim_spacing = (stim_spacing - mean(stim_spacing))/stim_spacing_mino*stim_spacing_mine + mean(stim_spacing);
end
stim_spacing_maxo = max(stim_spacing) - mean(stim_spacing);
stim_spacing_maxe = spacing_max - mean(stim_spacing);
if stim_spacing_maxe - stim_spacing_maxo < 0
    stim_spacing = (stim_spacing - mean(stim_spacing))/stim_spacing_maxo*stim_spacing_maxe + mean(stim_spacing);
end

%load data/intensive_radii_func.mat % Load the 4D relation matrix

[win screenRect]=Screen('OpenWindow',0,[0 0 0],[]); % Start PsychToolbox to get the screen resolution
Screen(win,'TextSize',20)
sca

for i = 1:T % Generating individual stimuli and adding them to the 'stimuli' struct
    it_stimuli_ratio = i/T
    stimuli_inst = stimgen_int(n,stim_isurf(i),stim_spacing(i),10,1080/2,spacing_med,item_surf_ex,radii_ex)
    stimuli(i).coord = stimuli_inst.coord;
    stimuli(i).spacing_o = stimuli_inst.spacing_o;
    stimuli(i).spacing_e = stimuli_inst.spacing_e;
    stimuli(i).spacing_rel_error_percent = stimuli_inst.spacing_rel_error_percent;
    stimuli(i).isa = stimuli_inst.isa;
    stimuli(i).radii = stimuli_inst.radii;
end

if saving == 1
    save('block_stim.mat','stimuli','n','T')
end

end